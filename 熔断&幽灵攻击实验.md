# 一、介绍

+ 攻击类型：系统硬件（System）层面

  > 硬件漏洞比软件漏洞麻烦得多，而且修复了会降低CPU性能和固态速度，导致当时包括INTEL、arm、AMD的芯片的升级都放缓了很多。

+ 编号：CVE-2017-5754  (与之成对出现的**幽灵攻击**：CVE-2017-5753)

+ 发现时间：2017年末
+ 攻击过程和结果：Meltdown 和 Spectre 利用了CPU的关键漏洞，导致攻击者得以窃取存储在内核内存中的秘密，包括存储在密码管理器或浏览器中的密码、用户个人照片、电子邮件、即时消息，甚至关键业务文档。
+ 攻击对象：个人计算机、移动设备和云中运行。

#二、预备知识

##1、侧信道攻击（Side-Channel Attacks)

![image-20220502141814515](熔断&幽灵攻击学习.assets/image-20220502141814515.png)

+ 类比微软面试题：灯泡发热的温度暴露了信息，从而知道了开关配对的“秘密”。

  ==这个例子中的侧信道是：灯泡发热带来的温度变化==

+ 另一个例子：假如想让电脑穷举验证密码，（假设真实密码是：hunter2）

  + 电脑从第一位密码开始猜：a——>不对；b——>不对；c——>不对；……

  + 当猜到h的时候——>（**电脑验证耗时变长**）不对

    因为电脑发现第一位匹配后，需要验证第二位是否匹配

  + 以此类推

  ==这个例子中的侧信道是：验证密码所用的运行时间==

## 2、乱序执行（Out-of-Order Execution）

   这里有3条语句：
**a**. `mov rax (rdx) `

**b**. `add rax $123 `

**c**. ` mov rcx (rbx)` 
     如果按照顺序执行的方式，cpu会依次执行这三条语句，先将内存中的数据放到rax中，在对rax中的数据做加法，再将rbx中的数据放到rcx中。

​     发现c指令需要的内存加载模块，在b指令处理时是**闲置**的。科学家可不想这样的资源浪费，所以乱序执行就应运而生。

​     乱序执行：CPU可能会在a执行完就将c中的数据加载到cache中，这样c语句的执行就会快很多。

+++

+ but！，乱序的时候并==**没有对进程的权限进行判断**==。比如说c语句访问的数据这个进程并不能修改，但是乱序执行仍会将他==**加载到cache**==中。

+ 在执行c语句时，操作系统才会进行权限的判断。如果发现进程并没有权限，就会放弃乱序执行的结果，==回滚==到最初的状态重新依次执行。

## 3、预测执行（Speculative Execution)

> 《计算机组成原理》学过，内存读取数据很慢、会让CPU留出很长的等待时间。
>
> 于是20年前提出了，为什么不让CPU推测需要执行的命令呢？

![image-20220430164441761](熔断攻击学习.assets/image-20220430164441761.png)

在这个例子中，CPU不等内存返回0还是1，跳过if判断，先**抢跑**（==不检查权限==）执行A、B、C、D；

+ 如果内存确实返回0，CPU已经成功超前运行

+ 如果内存返回的不是0，CPU需要**回滚**之前的执行结果

  +++

  but，这其中的问题是，==**当CPU回滚的时候，不会回滚cache！**==

  

# 三、幽灵&熔断攻击原理

+ 目标：我们想要知道Victim Memory里面的数据
+ 补充说明：操作系统确保一个程序无法访问属于其他程序的内存区块，不同程序的内存块被隔开

![image-20220502145622525](熔断&幽灵攻击学习.assets/image-20220502145622525.png)

+ 步骤：

  + 在可以合法访问的内存块中设一个数组（很小）——>图中绿色标注

  + 我们试图超过A的范围（越界读取），下标第x位；此时CPU会阻止这一操作，抛出错误“非法操作”

    ![image-20220502145645467](熔断&幽灵攻击学习.assets/image-20220502145645467.png)

  + 建立一个Instrument区域（我们可以把它比作的个钢琴，里面不同的元素是一个个琴键）

    ![image-20220502145702036](熔断&幽灵攻击学习.assets/image-20220502145702036.png)

  + 执行  **`if( ){access Instrument[A[x]]; }` **由于预测执行技术的存在，CPU会预先执行if语句里面的代码；

  + CPU执行了这个本不该执行的语句后，它需要看一下A[x]的值；这时，CPU**并未检查A[x]下标是否越界**（因为它认为之后总归会验证的，而==这就是关键==）

  + 假设A[x]=4，也就是Instrument[4]（形象描述为钢琴中的F音）

    接下来是攻击的核心一步：CPU访问Instrument[4]后，将其**==放入了cache！！！==**

    ![image-20220502145722899](熔断&幽灵攻击学习.assets/image-20220502145722899.png)

  + 最后我们只需要遍历Instrument，也就是弹一遍钢琴，就发现**F音弹得很快**！



# 五、实验部分

##· Task1：Reading from Cache VS Memory

###（1）实验步骤

+ 在代码中创建一个大小为10 * 4096的数组

  >  应该注意的是，缓存是在缓存块级别完成的，而不是字节级别。典型的缓存块大小为64字节。我们使用数组[k*4096]，因此程序中使用的两个元素**不会落入同一个缓存块**中。

+ 首先访问它的两个元素，比如数组[3* 4096]和数组[7* 4096]。包含这两个元素的页面将被缓存。

+ 然后，我们从数组[0* 4096]到数组[9* 4096]读取元素，并测量在内存读取中花费的时间。

  它们的差异如下图：

  ![image-20220504083057963](熔断&幽灵攻击实验.assets/image-20220504083057963.png)

+ 在代码中，`time1 = __rdtscp(&junk); (1)`在内存读取**之前读取CPU的时间戳（TSC）**计数器

  而`time2 = __rdtscp(&junk) - time1; (2)`在内存读取**之后读取计数器**。

+ 运行整个CacheTime.c 代码。

  比较数组[3* 4096]和数组[7* 4096]的访问速度与其他元素的差异；应该至少运行该程序10次，然后**==找到一个阈值==**，可以用来区分这两种类型的内存访问。

###（2）CacheTime.c 代码

```c
#include <emmintrin.h>
#include <x86intrin.h>
uint8_t array[10*4096];
int main(int argc, const char **argv) {
    int junk=0;
    register uint64_t time1, time2;
    volatile uint8_t *addr;
    int i;
// 初始化数组
    for(i=0; i<10; i++) array[i*4096]=1;
// 刷新缓存
    for(i=0; i<10; i++) _mm_clflush(&array[i*4096]);
// 访问这两个数组元素
    array[3*4096] = 100;
    array[7*4096] = 200;
    for(i=0; i<10; i++) {
        addr = &array[i*4096];
        time1 = __rdtscp(&junk);                   //(1)
        junk = *addr;
        time2 = __rdtscp(&junk) - time1;           //(2)
        printf("Access time for array[%d*4096]: %d CPU cycles\n",i, (int)time2);
    }
    return 0;
}
```

###（3）实验结果及分析

+ 第一次

  ![image-20220504084636437](熔断&幽灵攻击实验.assets/image-20220504084636437.png)

+ 第二次

  ![image-20220504084737245](熔断&幽灵攻击实验.assets/image-20220504084737245.png)

+ 第三次

  ![image-20220504084830550](熔断&幽灵攻击实验.assets/image-20220504084830550.png)

+ 第四次

  ![image-20220504084904080](熔断&幽灵攻击实验.assets/image-20220504084904080.png)

+ 第五次

  ![image-20220504085011712](熔断&幽灵攻击实验.assets/image-20220504085011712.png)

+ 第六次

  ![image-20220504085101503](熔断&幽灵攻击实验.assets/image-20220504085101503.png)

+ 第七次

  ![image-20220504085131001](熔断&幽灵攻击实验.assets/image-20220504085131001.png)

+ 第八次

  ![image-20220504085252704](熔断&幽灵攻击实验.assets/image-20220504085252704.png)

+ 第九次

  ![image-20220504085309967](熔断&幽灵攻击实验.assets/image-20220504085309967.png)

+ 第十次

  ![image-20220504085417109](熔断&幽灵攻击实验.assets/image-20220504085417109.png)

+ **实验分析**

  + ![image-20220504091219915](熔断&幽灵攻击实验.assets/image-20220504091219915.png)

    

  + ![image-20220504090655867](熔断&幽灵攻击实验.assets/image-20220504090655867.png)

![image-20220504090819112](熔断&幽灵攻击实验.assets/image-20220504090819112.png)



## · Task2：Side Channel Attack

## （1）实验步骤

+ 在代码中创建数组[256*4096]

  > **解释为什么是这样：**
  >
  > 因为一个单字节密码有256个可能的值，所以我们需要将每个值映射到一个数组元素。
  >
  > 又因为缓存是在块级别完成的，而不是在字节级别。如果访问数组[k]，包含该元素的内存块将被缓存。因此，数组[k]的相邻元素也将被缓存，这使得很难推断秘密是什么。
  >
  > 为了解决这个问题，我们创建了一个256* 4096字节的数组。重新加载步骤中使用的每个元素都是数组[k* 4096]。因为4096大于典型的缓存块大小（64字节），所以同一个缓存块中不会有两个不同的元素array[i* 4096]和array[j* 4096]。 
  >
  > 另外，由于数组[0* 4096]可能与**相邻内存中的变量落在同一个缓存块中**，因此可能会由于缓存这些变量而意外缓存。因此，我们应该避免在FLUSH+RELOAD方法中使用数组[0* 4096]。为了在程序中保持一致，我们对所有k值使用数组[k*4096+DELTA]，其中DELTA定义为常数1024。 

+ 刷新缓存，以确保实验用到的数组未被缓存。（Flush部分）

+ 调用受害者函数（victim function——有点像前面所说的 **`if( ){access Instrument[A[x]]; }` **），该函数读取秘密值并访问对应的数组元素。此操作导致相应的数组元素放入cache

+ 重新扫描整个阵列，并测量访问每个元素所需的时间。（Reload部分）

  如果某个特定元素的加载时间很快，则该元素很可能已经在缓存中，那么此元素即是受害者函数访问的元素，因此我们便知道了秘密值是多少。 

## （2）FlushReload.c代码

```c
#include <emmintrin.h>
#include <x86intrin.h>
uint8_t array[256*4096];  //uint8_t = unsigned char
int temp;
unsigned char secret = 94;
/* cache hit time threshold assumed*/
#define CACHE_HIT_THRESHOLD (80)//我们自己设的域
#define DELTA 1024
void flushSideChannel(){
    int i;
// 先写一遍，防止Copy-on-write（写入复制机制）
    for (i = 0; i < 256; i++) array[i*4096 + DELTA] = 1;
// Flush the values of the array from cache
    for (i = 0; i < 256; i++) _mm_clflush(&array[i*4096 +DELTA]);
}
void victim(){
    temp = array[secret*4096 + DELTA];
}
void reloadSideChannel(){
    int junk=0;
    register uint64_t time1, time2;//register修饰符暗示编译程序相应的变量将被频繁地使用
    volatile uint8_t *addr;//volatile定义变量时，CPU都从内存地址处重新取值
    int i;
    for(i = 0; i < 256; i++){
        addr = &array[i*4096 + DELTA];
        time1 = __rdtscp(&junk);//__rdtscp指令返回CPU自启动以来的时钟周期数
        junk = *addr;
        time2 = __rdtscp(&junk) - time1;
        if (time2 <= CACHE_HIT_THRESHOLD){
            printf("array[%d*4096 + %d] is in cache.\n", i, DELTA);
            printf("The Secret = %d.\n",i);
        }
    }
}
int main(int argc, const char **argv){
    flushSideChannel();
    victim();
    reloadSideChannel();
    return (0);
}
```



## （3）实验结果及分析

+ 按原代码执行

![image-20220504233155566](熔断&幽灵攻击实验.assets/image-20220504233155566.png)

+ 调整CACHE_HIT_THRESHOLD的值为70

![image-20220505000713246](熔断&幽灵攻击实验.assets/image-20220505000713246.png)

![image-20220505000840172](熔断&幽灵攻击实验.assets/image-20220505000840172.png)

+ 调整CACHE_HIT_THRESHOLD的值为200

![image-20220505001216570](熔断&幽灵攻击实验.assets/image-20220505001216570.png)

![image-20220505001124737](熔断&幽灵攻击实验.assets/image-20220505001124737.png)



# 六、防御检测方案

​     因为这两个漏洞分别是运用了两个技术：乱序执行和分支预测，这两个技术又可以提高cpu的工作效率，所以在操作系统层面的补丁势必会对这两项数据带来一定的影响，从而影响计算机工作的效率。
​     也就是说：为了安全考虑安装了这两个漏洞的补丁，那么就会降低系统的性能，如果个人电脑上面没有什么机密的信息，就可以 ***放弃这两个补丁的安装，以安全性换取更高的性能。***

==**？牺牲安全、提高性能？**==

+++

## 1、被动防御

###（1）KPTI防御

+ **应用：**

  针对该关键的硬件漏洞，KPTI作为**主流**的解决思路被 Intel、Arm 等采用。

  将“双页表”应用到了会受到 Meltdown 攻击的 MacOS、iOS、Linux、Windows、Android等操作系统上。微软发布的类似的补丁名为 KVA shadow，苹果也分别在 iOS 系统、MacOS 系统、以及 TVOS 系统发布了更新以缓解 meltdown 带来的影响，原理与 KPTI 相同。

+ **基本思想：**

  KPTI 通过**隔离==内核页表==与==用户页表==**限制用户对系统内核的访问。

  原进程地址空间中的内核空间和用户空间在同一张页表，才给了攻击程序在用户态获取内核数据的机会。KPTI 将用户空间与内核空间分隔开，内核模式下进程页表包括内核空间和用户空间在内的所有数据，而用户模式下只有用户空间的数据代码等以及尽可能少的内核数据和代码用于用户空间和内核空间的上下文交互。

+ **弊端：**

  KPTI 从 Meltdown 漏洞**源头**着手，从根本上封锁高权限数据泄露的可能，保证了系统的安全性。

  但是，由于同一进程的页表由一张变成了两张，==增加了页表切换（用户态与内核态之间）的系统开销==

  ==CPU性能会降低。==

![image-20220506091006737](熔断&幽灵攻击实验.assets/image-20220506091006737.png)

###（2）EPTI防御

EPTI 是由上海交通大学并行与分布式系统研究所提出的用于云服务器、虚拟机等**云设备**的防御手段。

+ **基本思路**：

  使用 EPTk 和 EPTu 两个扩展页表而非访客页表来隔离用户空间和内核空间。

  EPTk 用来运行内核进程，EPTu 用来运行用户进程，由于用户模式下用于映射内核地址空间的 g PT 条目在用户扩展页表中设置为 0 来禁止任何内核地址空间的转换，由此可在云服务中实现与 KPTI 相同的防御效果。

+ **优点**：

  EPT 的切换由==硬件特性支持==，不涉及虚拟机管理程序，并且每个 EPT 有自己的 TLB，因此 EPT 的交换并不会带来 TLB 的刷新，降低了页表切换的系统开销。

  > **TLB（translation lookaside buffer）**
  >
  > ——转换检测缓冲区，用于改进虚拟地址到物理地址转换速度的缓存

+ **缺点：**

  EPTI 是针对云服务器、虚拟机等云设备的特定防御手段，因此该防御方案不能推广，应用场景有限。
  



##2、主动防御

###· 天津大学硕士论文方案

主动检测：

利用segfault信号 提取特征 检测异常后刷新缓存



## 3、IDS 检测防御

###· Am-I-Affected-by-Meltdown

检测思路：**（特征提取）**

它通过使用 /proc/kallsyms 查找系统调用表并检查通过利用 MELTDOWN 找到的系统调用的地址是否与 /proc/kallsyms 中的相应地址匹配。

>为了更方便的调试内核代码，开发者考虑将内核代码中所有函数以及所有非栈变量的地址抽取出来，形成是一个简单的数据块(data blob:符号和地址对应)
>
>Linux内核符号表/proc/kallsyms的形成过程：
>
>+ ./scripts/kallsyms.c负责生成System.map
>+ ./kernel/kallsyms.c负责生成/proc/kallsyms



## 4、自己的想法

**3结合缓存刷新**
